<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
在实际应用中，我们总会碰到一些问题，比如希望一个app同时做几件事，或者在后台与服务器通信，或者为了不影响体验把一些耗时的计算和操作放在后台等等。`多线程` 就是解决该类问题一个有力武器，关于多线程的基础知识，大家可以移步到这里了解：[iOS开发多线程篇—多线程简单介绍](http://www.cnblogs.com/wendingding/p/3805088.html)。

###在IOS中，我们有以下几种使用多线程的方法：
1. NSThread
2. Cocoa NSOperation （iOS多线程编程之NSOperation和NSOperationQueue的使用）
3. GCD  全称：Grand Central Dispatch（ iOS多线程编程之Grand Central Dispatch(GCD)介绍和使用）


##NSThread
NSThread实现的技术有下面三种：
<table class="graybox       " border="0" cellspacing="0" cellpadding="5" style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(155, 179, 205); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(155, 179, 205); margin-bottom: 4em; color: rgb(0, 0, 0); font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; font-size: 13px; text-align: start; "><tbody><tr><th scope="col" class="TableHeading_TableRow_TableCell" style="font-weight: normal; background-color: rgb(147, 165, 187); padding: 0.3em 0.667em; font-size: 13px; color: rgb(255, 255, 255); border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0.33em; font-weight: bold; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Technology</p></th><th scope="col" class="TableHeading_TableRow_TableCell" style="font-weight: normal; background-color: rgb(147, 165, 187); padding: 0.3em 0.667em; font-size: 13px; color: rgb(255, 255, 255); border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0.33em; font-weight: bold; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Description</p></th></tr><tr><td scope="row" style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Cocoa threads</p></td><td style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Cocoa implements threads using the&nbsp;<code style="font-family: Courier, Consolas, monospace; color: rgb(102, 102, 102); "><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/Reference/Reference.html#//apple_ref/occ/cl/NSThread" target="_self" style="color: rgb(0, 51, 102); text-decoration: none; ">NSThread</a></code>&nbsp;class. Cocoa also provides methods on&nbsp;<code style="font-family: Courier, Consolas, monospace; color: rgb(102, 102, 102); "><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_self" style="color: rgb(0, 51, 102); text-decoration: none; ">NSObject</a></code>&nbsp;for spawning new threads and executing code on already-running threads. For more information, see&nbsp;<span class="content_text" style="margin-top: 0px; margin-bottom: 0.833em; padding-bottom: 0.833em; vertical-align: top; "><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW11" style="color: rgb(0, 51, 102); text-decoration: none; ">“Using NSThread”</a></span>&nbsp;and&nbsp;<span class="content_text" style="margin-top: 0px; margin-bottom: 0.833em; padding-bottom: 0.833em; vertical-align: top; "><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW13" style="color: rgb(0, 51, 102); text-decoration: none; ">“Using NSObject to Spawn a Thread.”</a></span></p></td></tr><tr><td scope="row" style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">POSIX threads</p></td><td style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">POSIX threads provide a C-based interface for creating threads. If you are not writing a Cocoa application, this is the best choice for creating threads. The POSIX interface is relatively simple to use and offers ample flexibility for configuring your threads. For more information, see&nbsp;<span class="content_text" style="margin-top: 0px; margin-bottom: 0.833em; padding-bottom: 0.833em; vertical-align: top; "><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW12" style="color: rgb(0, 51, 102); text-decoration: none; ">“Using POSIX Threads”</a></span></p></td></tr><tr><td scope="row" style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Multiprocessing Services</p></td><td style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Multiprocessing Services is a legacy C-based interface used by applications transitioning from older versions of Mac OS. This technology is available in OS X only and should be avoided for any new development. Instead, you should use the&nbsp;<code style="font-family: Courier, Consolas, monospace; color: rgb(102, 102, 102); ">NSThread</code>&nbsp;class or POSIX threads. If you need more information on this technology, see&nbsp;<em>Multiprocessing Services Programming Guide</em>.</p></td></tr></tbody></table>

iOS开发中一般只会用到NSThread和POSIX threads(p_thread).
p_thread是一套Ｃ的接口，GCD就是基于它实现的，我们在分析GCD的时候再来看它，现在单看看`NSThread`,下面是头文件：

    #import <Foundation/NSObject.h>
    #import <Foundation/NSDate.h>

    @class NSArray, NSMutableDictionary, NSDate;

    @interface NSThread : NSObject  {
    @private
        id _private;
        uint8_t _bytes[44];
    }

    + (NSThread *)currentThread;

    + (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument;

    + (BOOL)isMultiThreaded;

    @property (readonly, retain) NSMutableDictionary *threadDictionary;

    + (void)sleepUntilDate:(NSDate *)date;
    + (void)sleepForTimeInterval:(NSTimeInterval)ti;

    + (void)exit;

    + (double)threadPriority;
    + (BOOL)setThreadPriority:(double)p;

    @property double threadPriority NS_AVAILABLE(10_6, 4_0); // To be deprecated; use qualityOfService below

    @property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0); // read-only after the thread is started

    + (NSArray *)callStackReturnAddresses NS_AVAILABLE(10_5, 2_0);
    + (NSArray *)callStackSymbols NS_AVAILABLE(10_6, 4_0);

    @property (copy) NSString *name NS_AVAILABLE(10_5, 2_0);

    @property NSUInteger stackSize NS_AVAILABLE(10_5, 2_0);

    @property (readonly) BOOL isMainThread NS_AVAILABLE(10_5, 2_0);
    + (BOOL)isMainThread NS_AVAILABLE(10_5, 2_0); // reports whether current thread is main
    + (NSThread *)mainThread NS_AVAILABLE(10_5, 2_0);

    - (instancetype)init NS_AVAILABLE(10_5, 2_0) NS_DESIGNATED_INITIALIZER;
    - (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument NS_AVAILABLE(10_5, 2_0);

    @property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);
    @property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);
    @property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);

    - (void)cancel NS_AVAILABLE(10_5, 2_0);

    - (void)start NS_AVAILABLE(10_5, 2_0);

    - (void)main NS_AVAILABLE(10_5, 2_0);	// thread body method

    @end

    FOUNDATION_EXPORT NSString * const NSWillBecomeMultiThreadedNotification;
    FOUNDATION_EXPORT NSString * const NSDidBecomeSingleThreadedNotification;
    FOUNDATION_EXPORT NSString * const NSThreadWillExitNotification;

    @interface NSObject (NSThreadPerformAdditions)

    - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array;
    - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;
    // equivalent to the first method with kCFRunLoopCommonModes

    - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array NS_AVAILABLE(10_5, 2_0);
    - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);
    // equivalent to the first method with kCFRunLoopCommonModes
    - (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg NS_AVAILABLE(10_5, 2_0);

    @end

<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>在实际应用中，我们总会碰到一些问题，比如希望一个app同时做几件事，或者在后台与服务器通信，或者为了不影响体验把一些耗时的计算和操作放在后台等等。<code>多线程</code> 就是解决该类问题一个有力武器，关于多线程的基础知识，大家可以移步到这里了解：<a href="http://www.cnblogs.com/wendingding/p/3805088.html">iOS开发多线程篇—多线程简单介绍</a>。</p>

<h3 id="ios">在IOS中，我们有以下几种使用多线程的方法：</h3>

<ol>
<li>NSThread</li>
<li>Cocoa NSOperation （iOS多线程编程之NSOperation和NSOperationQueue的使用）</li>
<li>GCD  全称：Grand Central Dispatch（ iOS多线程编程之Grand Central Dispatch(GCD)介绍和使用）</li>
</ol>

<h2 id="nsthread">NSThread</h2>

<p>NSThread实现的技术有下面三种：</p>

<table class="graybox       " border="0" cellspacing="0" cellpadding="5" style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(155, 179, 205); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(155, 179, 205); margin-bottom: 4em; color: rgb(0, 0, 0); font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; font-size: 13px; text-align: start; "><tbody><tr><th scope="col" class="TableHeading_TableRow_TableCell" style="font-weight: normal; background-color: rgb(147, 165, 187); padding: 0.3em 0.667em; font-size: 13px; color: rgb(255, 255, 255); border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0.33em; font-weight: bold; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Technology</p></th><th scope="col" class="TableHeading_TableRow_TableCell" style="font-weight: normal; background-color: rgb(147, 165, 187); padding: 0.3em 0.667em; font-size: 13px; color: rgb(255, 255, 255); border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0.33em; font-weight: bold; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Description</p></th></tr><tr><td scope="row" style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Cocoa threads</p></td><td style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Cocoa implements threads using the&nbsp;<code style="font-family: Courier, Consolas, monospace; color: rgb(102, 102, 102); "><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/Reference/Reference.html#//apple_ref/occ/cl/NSThread" target="_self" style="color: rgb(0, 51, 102); text-decoration: none; ">NSThread</a></code>&nbsp;class. Cocoa also provides methods on&nbsp;<code style="font-family: Courier, Consolas, monospace; color: rgb(102, 102, 102); "><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject" target="_self" style="color: rgb(0, 51, 102); text-decoration: none; ">NSObject</a></code>&nbsp;for spawning new threads and executing code on already-running threads. For more information, see&nbsp;<span class="content_text" style="margin-top: 0px; margin-bottom: 0.833em; padding-bottom: 0.833em; vertical-align: top; "><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW11" style="color: rgb(0, 51, 102); text-decoration: none; ">“Using NSThread”</a></span>&nbsp;and&nbsp;<span class="content_text" style="margin-top: 0px; margin-bottom: 0.833em; padding-bottom: 0.833em; vertical-align: top; "><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW13" style="color: rgb(0, 51, 102); text-decoration: none; ">“Using NSObject to Spawn a Thread.”</a></span></p></td></tr><tr><td scope="row" style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">POSIX threads</p></td><td style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">POSIX threads provide a C-based interface for creating threads. If you are not writing a Cocoa application, this is the best choice for creating threads. The POSIX interface is relatively simple to use and offers ample flexibility for configuring your threads. For more information, see&nbsp;<span class="content_text" style="margin-top: 0px; margin-bottom: 0.833em; padding-bottom: 0.833em; vertical-align: top; "><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW12" style="color: rgb(0, 51, 102); text-decoration: none; ">“Using POSIX Threads”</a></span></p></td></tr><tr><td scope="row" style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Multiprocessing Services</p></td><td style="padding: 0.667em; font-size: 13px; vertical-align: middle; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(155, 179, 205); border-right-width: 1px; border-right-style: solid; border-right-color: rgb(155, 179, 205); "><p style="margin-top: 0px; margin-bottom: 0px; font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif; ">Multiprocessing Services is a legacy C-based interface used by applications transitioning from older versions of Mac OS. This technology is available in OS X only and should be avoided for any new development. Instead, you should use the&nbsp;<code style="font-family: Courier, Consolas, monospace; color: rgb(102, 102, 102); ">NSThread</code>&nbsp;class or POSIX threads. If you need more information on this technology, see&nbsp;<em>Multiprocessing Services Programming Guide</em>.</p></td></tr></tbody></table>

<p>iOS开发中一般只会用到NSThread和POSIX threads(p<em>thread).
p</em>thread是一套Ｃ的接口，GCD就是基于它实现的，我们在分析GCD的时候再来看它，现在单看看<code>NSThread</code>,下面是头文件：</p>

<pre><code>#import &lt;Foundation/NSObject.h&gt;
#import &lt;Foundation/NSDate.h&gt;

@class NSArray, NSMutableDictionary, NSDate;

@interface NSThread : NSObject  {
@private
    id _private;
    uint8_t _bytes[44];
}

+ (NSThread *)currentThread;

+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument;

+ (BOOL)isMultiThreaded;

@property (readonly, retain) NSMutableDictionary *threadDictionary;

+ (void)sleepUntilDate:(NSDate *)date;
+ (void)sleepForTimeInterval:(NSTimeInterval)ti;

+ (void)exit;

+ (double)threadPriority;
+ (BOOL)setThreadPriority:(double)p;

@property double threadPriority NS_AVAILABLE(10_6, 4_0); // To be deprecated; use qualityOfService below

@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0); // read-only after the thread is started

+ (NSArray *)callStackReturnAddresses NS_AVAILABLE(10_5, 2_0);
+ (NSArray *)callStackSymbols NS_AVAILABLE(10_6, 4_0);

@property (copy) NSString *name NS_AVAILABLE(10_5, 2_0);

@property NSUInteger stackSize NS_AVAILABLE(10_5, 2_0);

@property (readonly) BOOL isMainThread NS_AVAILABLE(10_5, 2_0);
+ (BOOL)isMainThread NS_AVAILABLE(10_5, 2_0); // reports whether current thread is main
+ (NSThread *)mainThread NS_AVAILABLE(10_5, 2_0);

- (instancetype)init NS_AVAILABLE(10_5, 2_0) NS_DESIGNATED_INITIALIZER;
- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument NS_AVAILABLE(10_5, 2_0);

@property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);
@property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);
@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);

- (void)cancel NS_AVAILABLE(10_5, 2_0);

- (void)start NS_AVAILABLE(10_5, 2_0);

- (void)main NS_AVAILABLE(10_5, 2_0);    // thread body method

@end

FOUNDATION_EXPORT NSString * const NSWillBecomeMultiThreadedNotification;
FOUNDATION_EXPORT NSString * const NSDidBecomeSingleThreadedNotification;
FOUNDATION_EXPORT NSString * const NSThreadWillExitNotification;

@interface NSObject (NSThreadPerformAdditions)

- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array;
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;
// equivalent to the first method with kCFRunLoopCommonModes

- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array NS_AVAILABLE(10_5, 2_0);
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);
// equivalent to the first method with kCFRunLoopCommonModes
- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg NS_AVAILABLE(10_5, 2_0);

@end
</code></pre>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2015 by Kobe, Designed by Kobe</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "多线程1.htm";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
