<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
属性在OC中就是快速定义一对存取器的语法特性。你可以在类的头文件，接口和类别人使定这种语法。下面是属性定义的组成格式：  

    @property (<#attributes#>) <#type#> <#name#>;

`property`是关键字，attributes则是属性的说明参数，type则是属性类型，name是属性名。  

    @property(copy) NSString *title;

上面这一行定义，语法展开后相当于下面两行定义：

    - (NSString *)title;
    - (void)setTitle:(NSString *)newTitle;

它定义了一套存取器，分别用来设置和获取值。我们再来看下属性的几组参数：  

1. retain  assign  copy  strong    weak     unsafe_unretained     autoreleasing
2. readwrite  readonly
3. nonatomic  atomic
4. setter  getter
其中第一组和内存有关，默认assign;第二组则是表示声明存取方法，或只有读取方法，默认readwrite;第三组则是原子性与否，和多线程有关，nonatomic表示非线程字全的，多线程访问可能有异常，但是效率高。atomic则是线程安全，但效率低，默认atomic。第四组则用来重命名set/get方法。

##synthesize
synthesize 关键字用来告诉编译器实现我们定义的属性，它和property是成对使用的。当然，写在类中它还可以做到给我们的属性变量重新取一个名字`@synthesize propertyName = newPropertyName`，默认变量名是属性名前面加个下划线`_`。

##普通类，接口，类别中的属性  
1. 普通类的属性是最齐全的，它们不仅含有一对存取器，还自动支持KVO,KVC,还包含有一个属性变量。  
2. 类别中的属性它其实只有一对存取器，没有实例变量。
3. 而接口中对属性的声明和在普通类的interface中没有区别，区别在于它的实现，在普通类中用`@synthesize `来实现它就和普通类一样，在类别中实现它就和类别一样，`它仅仅只是一段声明代码`。


推荐文章 ：  
[官方文档](https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/DevPedia-CocoaCore/DeclaredProperty.html#//apple_ref/doc/uid/TP40008195-CH13-SW1);  
[@property详解](http://www.mamicode.com/info-detail-605123.html);  
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>属性在OC中就是快速定义一对存取器的语法特性。你可以在类的头文件，接口和类别人使定这种语法。下面是属性定义的组成格式：  </p>

<pre><code>@property (&lt;#attributes#&gt;) &lt;#type#&gt; &lt;#name#&gt;;
</code></pre>

<p><code>property</code>是关键字，attributes则是属性的说明参数，type则是属性类型，name是属性名。  </p>

<pre><code>@property(copy) NSString *title;
</code></pre>

<p>上面这一行定义，语法展开后相当于下面两行定义：</p>

<pre><code>- (NSString *)title;
- (void)setTitle:(NSString *)newTitle;
</code></pre>

<p>它定义了一套存取器，分别用来设置和获取值。我们再来看下属性的几组参数：  </p>

<ol>
<li>retain  assign  copy  strong    weak     unsafe_unretained     autoreleasing</li>
<li>readwrite  readonly</li>
<li>nonatomic  atomic</li>
<li>setter  getter
其中第一组和内存有关，默认assign;第二组则是表示声明存取方法，或只有读取方法，默认readwrite;第三组则是原子性与否，和多线程有关，nonatomic表示非线程字全的，多线程访问可能有异常，但是效率高。atomic则是线程安全，但效率低，默认atomic。第四组则用来重命名set/get方法。</li>
</ol>

<h2 id="synthesize">synthesize</h2>

<p>synthesize 关键字用来告诉编译器实现我们定义的属性，它和property是成对使用的。当然，写在类中它还可以做到给我们的属性变量重新取一个名字<code>@synthesize propertyName = newPropertyName</code>，默认变量名是属性名前面加个下划线<code>_</code>。</p>

<h2 id="">普通类，接口，类别中的属性</h2>

<ol>
<li>普通类的属性是最齐全的，它们不仅含有一对存取器，还自动支持KVO,KVC,还包含有一个属性变量。  </li>
<li>类别中的属性它其实只有一对存取器，没有实例变量。</li>
<li>而接口中对属性的声明和在普通类的interface中没有区别，区别在于它的实现，在普通类中用<code>@synthesize</code>来实现它就和普通类一样，在类别中实现它就和类别一样，<code>它仅仅只是一段声明代码</code>。</li>
</ol>

<p>推荐文章 ： <br>
<a href="https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/DevPedia-CocoaCore/DeclaredProperty.html#//apple_ref/doc/uid/TP40008195-CH13-SW1">官方文档</a>; <br>
<a href="http://www.mamicode.com/info-detail-605123.html">@property详解</a>;  </p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2015 by Kobe, Designed by Kobe</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "属性.htm";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
